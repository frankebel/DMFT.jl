using DMFT
using Fermions
using LinearAlgebra
using Test

@testset "natural orbitals" begin
    @testset "matrix transformation" begin
        Δ = get_hyb(11)
        m = Array(Δ)
        H, n_occ = to_natural_orbitals(m)

        @test n_occ === 6
        @test size(H) === (12, 12)
        d = diag(H)
        @test norm(d[1:6] + d[7:12]) < 3E-14 # PHS
        @test ishermitian(H)
        @test H ≈ [
            -5.551115123125783e-17 0.3666114760822126 0.0 0.0 0.0 0.0 -0.8550976851855241 -0.3666114760822127 0.0 0.0 0.0 0.0
            0.3666114760822126 -1.0152302184087838 0.4711704775408592 0.0 0.0 0.0 0.36661147608221256 0.0 0.0 0.0 0.0 0.0
            0.0 0.4711704775408592 -1.103069038676343 -0.4209553704382026 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0
            0.0 0.0 -0.4209553704382026 -1.224241080048526 -0.3460825268674939 0.0 0.0 0.0 0.0 0.0 0.0 0.0
            0.0 0.0 0.0 -0.3460825268674939 -1.4077773642670075 0.23057025892190525 0.0 0.0 0.0 0.0 0.0 0.0
            0.0 0.0 0.0 0.0 0.23057025892190525 -1.690814423972567 0.0 0.0 0.0 0.0 0.0 0.0
            -0.8550976851855241 0.36661147608221256 0.0 0.0 0.0 0.0 2.220446049250313e-16 0.36661147608221273 0.0 0.0 0.0 0.0
            -0.3666114760822127 0.0 0.0 0.0 0.0 0.0 0.36661147608221273 1.0152302184087854 -0.47117047754086055 0.0 0.0 0.0
            0.0 0.0 0.0 0.0 0.0 0.0 0.0 -0.47117047754086055 1.103069038676346 0.42095537043820225 0.0 0.0
            0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.42095537043820225 1.2242410800485246 -0.3460825268674972 0.0
            0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 -0.3460825268674972 1.4077773642670095 -0.2305702589219088
            0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 -0.2305702589219088 1.690814423972562
        ] atol = 1E-13

        Δ = get_hyb(301)
        m = Array(Δ)
        H, n_occ = to_natural_orbitals(m)
        @test n_occ === 151
        E = eigvals(H)
        @test norm(E[1:151] + reverse(E[152:end])) < 8E-8

        # non-hermitian matrix
        m = rand(10, 10)
        @test_throws ArgumentError to_natural_orbitals(m)

        # complex matrix
        m = rand(ComplexF64, 10, 10)
        m = 0.5 * (m + m')
        @test_throws MethodError to_natural_orbitals(m)
    end # matrix transformation

    @testset "operator" begin
        # H_nat1 has 0 in irrelevant entries, H_nat2 has all values set.
        # Both should still result in the same Hamiltonian.
        H_nat1 = [
            0 2 0 4 5 0
            2 8 9 10 0 0
            0 9 15 0 0 0
            4 10 0 22 23 0
            5 0 0 23 29 30
            0 0 0 0 30 36
        ]
        H_nat2 = [
            1 2 3 4 5 6
            2 8 9 10 11 12
            3 9 15 16 17 18
            4 10 16 22 23 24
            5 11 17 23 29 30
            6 12 18 24 30 36
        ]
        n_occ = 3
        U = 37
        μ = 38

        @testset "Operator" begin
            fs = FockSpace(Orbitals(12), FermionicSpin(1//2))
            H1 = natural_orbital_operator(H_nat1, U, -μ, fs, n_occ, 1, 1)
            H2 = natural_orbital_operator(H_nat2, U, -μ, fs, n_occ, 1, 1)
            @test H1 == H2

            c = annihilators(fs)
            n = occupations(fs)
            H3 =
            # impurity
                U * n[1, 1//2] * n[1, -1//2] +
                -38 * n[1, -1//2] +
                -38 * n[1, 1//2] +
                # mirror site
                22 * n[2, -1//2] +
                22 * n[2, 1//2] +
                # bit component
                8 * n[3, -1//2] +
                8 * n[3, 1//2] +
                29 * n[4, -1//2] +
                29 * n[4, 1//2] +
                # vector component
                15 * n[5, -1//2] +
                15 * n[5, 1//2] +
                36 * n[6, -1//2] +
                36 * n[6, 1//2] +
                # hopping i <-> b
                4 * c[1, -1//2]' * c[2, -1//2] +
                4 * c[2, -1//2]' * c[1, -1//2] +
                4 * c[1, 1//2]' * c[2, 1//2] +
                4 * c[2, 1//2]' * c[1, 1//2] +
                # hopping i <-> other
                2 * c[1, -1//2]' * c[3, -1//2] +
                2 * c[3, -1//2]' * c[1, -1//2] +
                2 * c[1, 1//2]' * c[3, 1//2] +
                2 * c[3, 1//2]' * c[1, 1//2] +
                5 * c[1, -1//2]' * c[4, -1//2] +
                5 * c[4, -1//2]' * c[1, -1//2] +
                5 * c[1, 1//2]' * c[4, 1//2] +
                5 * c[4, 1//2]' * c[1, 1//2] +
                # hopping b <-> other
                10 * c[2, -1//2]' * c[3, -1//2] +
                10 * c[3, -1//2]' * c[2, -1//2] +
                10 * c[2, 1//2]' * c[3, 1//2] +
                10 * c[3, 1//2]' * c[2, 1//2] +
                23 * c[2, -1//2]' * c[4, -1//2] +
                23 * c[4, -1//2]' * c[2, -1//2] +
                23 * c[2, 1//2]' * c[4, 1//2] +
                23 * c[4, 1//2]' * c[2, 1//2] +
                # hopping v
                9 * c[3, -1//2]' * c[5, -1//2] +
                9 * c[5, -1//2]' * c[3, -1//2] +
                9 * c[3, 1//2]' * c[5, 1//2] +
                9 * c[5, 1//2]' * c[3, 1//2] +
                # hopping c
                30 * c[4, -1//2]' * c[6, -1//2] +
                30 * c[6, -1//2]' * c[4, -1//2] +
                30 * c[4, 1//2]' * c[6, 1//2] +
                30 * c[6, 1//2]' * c[4, 1//2]
            @test H1 == H3

            # raise sites in bit component
            H1 = natural_orbital_operator(H_nat1, U, -μ, fs, n_occ, 2, 2)
            H2 = natural_orbital_operator(H_nat2, U, -μ, fs, n_occ, 2, 2)
            @test H1 == H2
            H3 =
            # impurity
                U * n[1, 1//2] * n[1, -1//2] +
                -38 * n[1, -1//2] +
                -38 * n[1, 1//2] +
                # mirror site
                22 * n[2, -1//2] +
                22 * n[2, 1//2] +
                # bit component
                8 * n[3, -1//2] +
                8 * n[3, 1//2] +
                15 * n[4, -1//2] +
                15 * n[4, 1//2] +
                29 * n[5, -1//2] +
                29 * n[5, 1//2] +
                36 * n[6, -1//2] +
                36 * n[6, 1//2] +
                # hopping i <-> b
                4 * c[1, -1//2]' * c[2, -1//2] +
                4 * c[2, -1//2]' * c[1, -1//2] +
                4 * c[1, 1//2]' * c[2, 1//2] +
                4 * c[2, 1//2]' * c[1, 1//2] +
                # hopping i <-> other
                2 * c[1, -1//2]' * c[3, -1//2] +
                2 * c[3, -1//2]' * c[1, -1//2] +
                2 * c[1, 1//2]' * c[3, 1//2] +
                2 * c[3, 1//2]' * c[1, 1//2] +
                5 * c[1, -1//2]' * c[5, -1//2] +
                5 * c[5, -1//2]' * c[1, -1//2] +
                5 * c[1, 1//2]' * c[5, 1//2] +
                5 * c[5, 1//2]' * c[1, 1//2] +
                # hopping b <-> other
                10 * c[2, -1//2]' * c[3, -1//2] +
                10 * c[3, -1//2]' * c[2, -1//2] +
                10 * c[2, 1//2]' * c[3, 1//2] +
                10 * c[3, 1//2]' * c[2, 1//2] +
                23 * c[2, -1//2]' * c[5, -1//2] +
                23 * c[5, -1//2]' * c[2, -1//2] +
                23 * c[2, 1//2]' * c[5, 1//2] +
                23 * c[5, 1//2]' * c[2, 1//2] +
                # # hopping v
                9 * c[3, -1//2]' * c[4, -1//2] +
                9 * c[4, -1//2]' * c[3, -1//2] +
                9 * c[3, 1//2]' * c[4, 1//2] +
                9 * c[4, 1//2]' * c[3, 1//2] +
                # # hopping c
                30 * c[5, -1//2]' * c[6, -1//2] +
                30 * c[6, -1//2]' * c[5, -1//2] +
                30 * c[5, 1//2]' * c[6, 1//2] +
                30 * c[6, 1//2]' * c[5, 1//2]
            @test H1 == H3

            # non-hermitian
            @test_throws ArgumentError natural_orbital_operator(
                rand(Int, 6, 6), U, -μ, fs, n_occ, 1, 1
            )
        end # Operator
    end # operator
end # natural orbitals
